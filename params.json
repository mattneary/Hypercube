{"name":"Hypercube","tagline":"Rubik's cube manipulation for Ruby.","body":"Hypercube\r\n=========\r\n\r\nIntroduction\r\n------------\r\nHypercube is a Rubik's cube simulator for Ruby. Face-turns are lambdas that modify a given `Cube` object via `Cube#faceTurn`. These lambdas can then be composed via the infix operator `*`.\r\n\r\nA usual Hypercube program would instantiate a cube, manipulate it with face-turns, and output the cube. However, more complex workflows are easily implemented; you can output facelet permutations or a side-by-side grid of cube states.\r\n\r\nFaceturns\r\n---------\r\nYou will most likely begin with something like the following.\r\n\r\n```ruby\r\ncube = Cube.new()\r\n\r\nU = lambda { |cube| cube.faceTurn :U }\r\nD = lambda { |cube| cube.faceTurn :D }\r\nL = lambda { |cube| cube.faceTurn :L }\r\nR = lambda { |cube| cube.faceTurn :R }\r\nF = lambda { |cube| cube.faceTurn :F }\r\nB = lambda { |cube| cube.faceTurn :B }\r\n```\r\n\r\nAfter having defined these shorthands and instantiated a cube you can compose face-turns with the `*` operator and access their inverses via `Proc#inv`. The following performs a corner orientation algorithm and outputs the result.\r\n\r\n```ruby\r\n(R * U * R.inv * U * R * U * U * R.inv * U * U)[cube]\r\nprint cube.to_s\r\n```\r\n\r\nCube Structure\r\n--------------\r\nA cube is represented as an array of faces, which in turn are arrays of up- and down-layer, which are in turn pairs of left- and right-facelet. These arrays are addressed with symbols `:U, :D, ... :B` as well as `:_L` and `:_R`. The latter are used exclusively for the third layer down, access of a specific facelet.\r\n\r\nThe default cube holds at each of the above articulated locations an array that serves as an address. For example:\r\n\r\n```ruby\r\nrubik = Cube.new\r\nrubik[:U][:U][:_L] == [rubik.U, rubik.U, rubik._L]\r\n```\r\n\r\nOf course the reason for this equivalence is that we are dealing with a default cube. Upon manipulation the value at a facelet location will point to its origin and allow the facelet to be uniquely identitifed.\r\n\r\nAnalysis\r\n--------\r\nHypercube aims to make analysis of Rubik's cube moves as straight-forward as possible. \r\n\r\n1. `Cube#delta(other, simple)` - outputs the permutations separating one cube state from another.\r\n2. `Cube#join_to_s(other, simple)` - forms a table of the cube with another beside it, output can be simplified to merely color rather than specific facelets.\r\n\r\nOnce the permutations of a move sequence have been identitifed, many conclusions may be reached; for example:\r\n\r\n- The region of manipulation, i.e., the *support*.\r\n- The period of the move sequence, i.e., the *order*.\r\n- Intermediary states of an algorithm to give insight into the inner-workings of an algorithm.\r\n\r\nClosing Words\r\n-------------\r\nHypercube is a work in progress. I hope to soon expand to a full 3x3x3 cube after I've made good progress in my research on group theory of the Rubik's cube. Its inspiration was to aid in derivation of algorithms.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}